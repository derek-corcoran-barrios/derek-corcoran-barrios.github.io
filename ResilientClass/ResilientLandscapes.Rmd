---
title: "Resilient Landscapes"
author: "Derek Corcoran"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      message = FALSE,
                      error = FALSE)

library(ggplot2)
library(tidyterra)
library(leaflet.minicharts)
library(leaflet)
library(plotly)
library(htmlwidgets)
library(leafpop)
library(tidyverse)
library(gganimate)
library(ggrepel)
library(terra)
```

## Resilience on maps


```{r}
knitr::include_graphics("TP_animation_CB.gif")
```


## Resiliency

```{r, echo=FALSE}
simulate_abundance <- function(ecosystem, steady_state, stressor_start, stressor_duration, stressor_slope = -0.1, recovery_duration, recovery_slope = 0.1, top_recovery = 100, noise = 2) {
  time <- seq(1, (stressor_start + stressor_duration + recovery_duration))
  
  abundance <- c(rep(steady_state, stressor_start - 1),
                 steady_state * exp(stressor_slope * (1:stressor_duration)))
  
  Min <- min(abundance)
  
  Left <- length(time) - length(abundance)
  
  recovery <- c(Min * exp(recovery_slope * (1:Left)))
  
  recovery <- ifelse(recovery > top_recovery, top_recovery, recovery)
  
  abundance <- c(abundance, recovery)
  
  abundance <- abundance + rnorm(length(abundance), mean = 0, sd = noise)
  
  data.frame(time = time, ecosystem = rep(ecosystem, length(time)), abundance = abundance, stressor_duration = stressor_duration, stressor_slope = stressor_slope, recovery_slope = recovery_slope)
}

resistent <- simulate_abundance("resistent", steady_state = 100, stressor_start = 31, stressor_duration = 2, stressor_slope = -0.05, recovery_slope = 0.1,recovery_duration = 67)

resilient <- simulate_abundance("resilient", steady_state = 100, stressor_start = 31, stressor_duration = 10, recovery_duration = 59,  stressor_slope = -0.05, recovery_slope = 0.1)

non_resilient <- simulate_abundance("non-resilient", steady_state = 100, stressor_start = 31, stressor_duration = 10, recovery_duration = 59,  stressor_slope = -0.05, recovery_slope = 0.04,  top_recovery = 70)


all_data <- dplyr::bind_rows(resistent, resilient, non_resilient)

accumulate_by <- function(dat, var) {
  var <- lazyeval::f_eval(var, dat)
  lvls <- plotly:::getLevels(var)
  dats <- lapply(seq_along(lvls), function(x) {
    cbind(dat[var %in% lvls[seq(1, x)], ], frame = lvls[[x]])
  })
  dplyr::bind_rows(dats)
}


fig <- all_data
fig <- fig %>% accumulate_by(~time)

gg <- ggplot(fig, aes(x=time, y=abundance)) +
  geom_vline(xintercept = 30, lty = 2) +
  geom_path(aes(frame = frame, color = ecosystem)) + facet_grid(ecosystem~.) + theme_bw() + theme(legend.position = "none")
gg <- ggplotly(gg)

gg <- gg %>% animation_opts(
  frame = 100, 
  transition = 0, 
  redraw = FALSE
)
gg <- gg %>% animation_slider(
  hide = T
)
gg <- gg %>% animation_button(
  x = 1, xanchor = "right", y = 0, yanchor = "bottom"
)
gg
```

## Popup graph



## Right balance between heterogeneity (mosaic) and continuity Large patch size


# Introduction

Ecosystem Landscape Resilience is a critical concept in ecology, focusing on the ability of landscapes to absorb disturbances and recover to a stable state. In this example, we'll simulate landscape dynamics using R, considering scenarios with different spatial configurations of forests and agriculture. The simulation will incorporate disturbances, recovery mechanisms, and the influence of neighboring cells on recovery.

# Landscape Simulation

## Creating Landscape Grids

We start by creating two landscape scenarios: one with a sparse distribution of forests and agriculture, and another with a more abundant forest core surrounded by agriculture.

```{r}
# Insert R code for creating landscape grids
```

Simulating Disturbances and Recovery

Next, we simulate disturbances and recovery processes on the landscape grids. Disturbances are introduced to forest cells with a certain probability, and recovery follows either a resilient or non-resilient path. Additionally, neighboring cells that have already recovered provide a subsidy to the current cell.


# Insert R code for simulating disturbances and recovery

Results

Let's visualize the landscape scenarios and their dynamics over time. We'll use ggplot2 for the visualization.



# Insert R code for visualization (ggplot2 or other libraries)

Discussion

The simulation demonstrates how landscape resilience varies with different spatial configurations. The interplay between disturbance, recovery, and the influence of neighboring cells provides insights into the dynamics of ecosystems at a landscape scale. Understanding these processes is crucial for effective ecosystem management and conservation.
Conclusion

In this example, we' ve explored a simple simulation of landscape resilience, emphasizing the importance of spatial configuration in influencing ecosystem dynamics. This simulation can serve as a foundation for further discussions and explorations in the field of Ecosystem Landscape Resilience.


```{r}
Resilients <- list()
Plots <- list()
  
for(i in 1:30){
  Resilients[[i]] <- simulate_abundance("resilient", steady_state = 100, stressor_start = 31, stressor_duration = 10, recovery_duration = 59,  stressor_slope = -0.05, recovery_slope = 0.1)
  Plots[[i]] <- ggplot(Resilients[[i]], aes(x = time, y = abundance)) + geom_path() + theme_bw()
}

Resilients <- Resilients |> 
  purrr::reduce(dplyr::bind_rows)


Resilients_sum <- Resilients |> 
  summarise(abundance = sum(abundance), .by = time)


non_resilients <- list()

for(i in 1:5){
  non_resilients[[i]] <- simulate_abundance("non-resilient", steady_state = 100, stressor_start = 31, stressor_duration = 10, recovery_duration = 59,  stressor_slope = -0.05, recovery_slope = 0.04,  top_recovery = 70)
  Plots[[i + 30]] <- ggplot(non_resilients[[i]], aes(x = time, y = abundance)) + geom_path() + theme_bw()
}

non_resilients <- non_resilients |> 
  purrr::reduce(dplyr::bind_rows)


non_resilients_sum <- non_resilients |> 
  summarise(abundance = sum(abundance), .by = time)

Forest <- terra::rast("Forest.tif")


Forest_Int <- terra::rast("Forest_Int.tif")

Forest_Poly <- terra::ifel(Forest_Int == 1, 1, NA) |> 
  as.polygons() |> disagg()

Forest_Poly$area <- terra:::expanse(Forest_Poly, unit = "ha")

BigArea <- Forest_Poly[Forest_Poly$area == max(Forest_Poly$area),]


ContArea <- crop(Forest, BigArea)

set.seed(2024)
Sample <- spatSample(ContArea, 100, xy = TRUE, as.points = T) |> 
  tidyterra::slice_max(order_by = focal_mean, n = 35) |> 
  tidyterra::arrange(desc(focal_mean)) 

Sample$ID <- 1:nrow(Sample)

set.seed(2024)

Sample$Type <- sample(c("Resilient", "Non-resilient"), size = nrow(Sample), replace = T, prob = c(0.85, 0.15))

Sample <- Sample |> tidyterra::arrange(desc(Type))



Sample_sf <- terra::project(Sample, y = "epsg:4623")

Pal <- colorFactor(c("red", "blue"), domain = sort(Sample_sf$Type))


leaflet() |> addProviderTiles("Esri.WorldImagery") |> 
  addCircleMarkers(data = Sample_sf, radius = 3, color = ~Pal(Type), group = "pnt") |> 
  addPopupGraphs(Plots, group = "pnt", width = 300, height = 400)

```

## Cumulative

```{r}
all <- dplyr::bind_rows(Resilients, non_resilients) |> 
  summarise(abundance = sum(abundance), .by = time)

ggplot(all, aes(x = time, y = abundance)) + geom_path()
```

